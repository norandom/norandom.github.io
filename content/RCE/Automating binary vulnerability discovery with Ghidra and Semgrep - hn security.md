---
title: "Automating binary vulnerability discovery with Ghidra and Semgrep - hn security"
source: "https://security.humanativaspa.it/automating-binary-vulnerability-discovery-with-ghidra-and-semgrep/"
author:
  - "[[Marco Ivaldi]]"
  - "[[https://security.humanativaspa.it/automating-binary-vulnerability-discovery-with-ghidra-and-semgrep/]]"
published: 2022-07-07T05:51:44+00:00, 2022-07-07T05:51:44+00:00
created: 2024-11-14
description: "“Humans are more suited to recognize […]"
tags:
  - "clippings"
---
> *“Humans are more suited to recognize food than to keep large graphs in their head.”*  
> *— Halvar Flake*

### TL;DR

I’ve released some tools to help **automate vulnerability discovery** tasks via **static analysis** techniques:

- [Rhabdomancer](https://github.com/0xdea/ghidra-scripts/blob/main/Rhabdomancer.java) is a simple [Ghidra](https://ghidra-sre.org/) script that locates all **calls to potentially insecure API functions** in a binary. Auditors can backtrace from these candidate points to find pathways allowing access from untrusted input.
- [Haruspex](https://github.com/0xdea/ghidra-scripts/blob/main/Haruspex.java) is another Ghidra script that is able to **extract all pseudo-code** generated by the Ghidra decompiler in a format that should be suitable to be imported into an IDE, such as [VS Code](https://code.visualstudio.com/), or parsed by static analysis tools, such as [Semgrep](https://semgrep.dev/).
- [My Semgrep rules](https://github.com/0xdea/semgrep-rules) are specially crafted to help auditors **identify potential bugs and locate hotspots in C/C++ code** on which to focus their attention.

[Semgrep](https://security.humanativaspa.it/semgrep-ruleset-for-c-c-vulnerability-research/) is a static analysis tool that works on source code, but thanks to Haruspex we can leverage its power also against **closed source binaries**.

### Becoming a (better) security researcher

For [some reason](https://en.wikipedia.org/wiki/WarGames), I’ve always been fascinated by [computer hacking](http://www.catb.org/jargon/html/H/hacker.html). I’ve been lucky enough to make hacking [my profession](https://www.linkedin.com/in/raptor/) and I’ve been at it almost non-stop for [more than two decades](https://packetstormsecurity.com/files/author/191/). Over the years, however, I’ve been sidetracked by my [management career](https://vimeo.com/447602353) and for a while I almost stopped developing [exploits](https://www.exploit-db.com/?author=315).

Recently, I decided I wanted to **get back in shape as a security researcher**.

![](https://security.humanativaspa.it/sec/wp-content/uploads/2022/04/Screenshot-2022-04-19-at-09.46.45-1024x576.jpg)

During my journey, among [other things](https://security.humanativaspa.it/ive-been-published-on-phrack/), I produced a trilogy of talks about vulnerability research and exploit development, with a focus on **proprietary and closed-source software**. If you’re interested in hunting for vulnerabilities in binary code and you have some spare time, I suggest you brush up on some concepts by watching the following videos.

#### A Bug’s Life: Story of a Solaris 0day

<iframe title="A Bug's Life: Story of a Solaris 0day - Marco Ivaldi - INFILTRATE 2019" src="https://player.vimeo.com/video/335197685?dnt=1&amp;app_id=122963" width="640" height="360" frameborder="0" allow="autoplay; fullscreen; picture-in-picture; clipboard-write"></iframe>

Party pack: [https://github.com/0xdea/raptor\_infiltrate19](https://github.com/0xdea/raptor_infiltrate19)

#### The INFILTRATE Effect: 6 Bugs in 6 Months

<iframe title="MARCO IVALDI: The INFILTRATE Effect: 6 Bugs in 6 Months" src="https://player.vimeo.com/video/474793702?dnt=1&amp;app_id=122963" width="640" height="360" frameborder="0" allow="autoplay; fullscreen; picture-in-picture; clipboard-write"></iframe>

Party pack: [https://github.com/0xdea/raptor\_infiltrate20](https://github.com/0xdea/raptor_infiltrate20)

#### My Last Solaris Talk (Not Your Average Keynote)

![](https://www.youtube.com/watch?v=Nc9ZLTb2hQ8)

Party pack: [https://github.com/0xdea/raptor\_romhack21](https://github.com/0xdea/raptor_romhack21)

### Challenges of binary vulnerability discovery

Now that we are on the same page with the fundamentals, it’s time to explore the challenges of vulnerability discovery in binary code. In this article, I purposefully won’t cover dynamic analysis and fuzzing. Instead, I’m going to focus on **static analysis**.

![](https://security.humanativaspa.it/sec/wp-content/uploads/2022/04/Screenshot-2022-04-19-at-09.47.54-1024x576.jpg)

If it’s an undeniable truth that **your ultimate target is the binary**, having the source code at your disposal during the audit helps a lot. Binary analysis is cumbersome and usually slower than source code analysis, and it requires a deeper low-level knowledge of the target platform and compiler implementation. Static analysis tasks in particular benefit of access to the source code, and there are many commercial and free tools that aim to automate some of these tasks.

One such tool is **Semgrep**. I’m pretty fond of it and I’ve already covered it in some detail in a [previous article](https://security.humanativaspa.it/semgrep-ruleset-for-c-c-vulnerability-research/). After developing a [C/C++ ruleset](https://github.com/0xdea/semgrep-rules) focused on vulnerability discovery, I had the idea to **apply it to the pseudo-code** generated by a decompiler to speed up binary analysis. This isn’t an original idea: other researchers have recently applied this concept in slightly [different](https://joern.io/blog/joern-supports-binary/) [ways](https://www.s3.eurecom.fr/docs/asiaccs22_mantovani.pdf). It turns out this approach is quite effective, albeit with some limitations. It’s not perfect, but **\*it works\***.

### A binary bug hunting toolkit

When I began my journey into becoming a better vulnerability researcher, I wanted to understand what I was doing instead of blindly firing up tools against target binaries. Therefore, I almost exclusively focused on **manual analysis**. Of course, this gets old pretty fast, especially with large binaries.

To improve my performance (and learn [Ghidra scripting](https://ghidra.re/ghidra_docs/api/index.html) while I was at it), I developed [Rhabdomancer](https://github.com/0xdea/ghidra-scripts/blob/main/Rhabdomancer.java), a simple [Ghidra](https://ghidra-sre.org/) script that locates all **calls to potentially insecure API functions** in a binary. Auditors can backtrace from these candidate points to find pathways allowing access from untrusted input. Coupled with manual analysis, this allowed to discover some interesting [vulnerabilities](https://security.humanativaspa.it/multiple-vulnerabilities-in-zyxel-zysh) in large binaries in a reasonable amount of time.

The next logical step was to **extract all pseudo-code** generated by the Ghidra decompiler in a format suitable to be imported into an IDE, such as [VS Code](https://code.visualstudio.com/), or parsed by static analysis tools, such as [Semgrep](https://semgrep.dev/). This is exactly what my [Haruspex](https://github.com/0xdea/ghidra-scripts/blob/main/Haruspex.java) script does. This setup should help auditors **identify potential bugs and locate hotspots in binary code** on which to focus their attention. Let’s see it in action against a real target.

### It’s showtime!

We’re now going to apply my toolkit against some **real-world vulnerabilities** in **Zyxel ZyWALL Unified Security Gateway (USG)** appliances that I’ve recently [discovered](https://security.humanativaspa.it/multiple-vulnerabilities-in-zyxel-zysh) and [reported](https://github.com/hnsecurity/vulns/blob/main/HNS-2022-02-zyxel-zysh.txt) to Zyxel.

The following **memory corruption bugs** in the zysh binary were collectively assigned [CVE-2022-26531](https://www.zyxel.com/support/multiple-vulnerabilities-of-firewalls-AP-controllers-and-APs.shtml):

- Buffer overflows in the “configure terminal > diagnostic” command.
- Buffer overflow in the “debug” command.
- Buffer overflow in the “ssh” command.
- Format string bugs in the “extension” argument of some commands.

The following **command injection vulnerability** in the zysh binary was assigned [CVE-2022-26532](https://www.zyxel.com/support/multiple-vulnerabilities-of-firewalls-AP-controllers-and-APs.shtml):

- OS command injection in the “packet-trace” command.

To use **Rhabdomancer** against the zysh binary, we follow these steps:

1. Auto analyze our target binary with the default analyzers (at least).
2. Copy the script into our “ghidra\_scripts” directory.
3. Open the Script Manager in Ghidra and run the script (or run it via the Tools > Rhabdomancer menu or the shortcut “Y”).
4. Open Window > Comments and navigate \[BAD\] candidate points in different badness tiers.

In the following screenshot, we can see an example of Rhabdomancer-generated comments (in some case edited following manual analysis) for our target binary:

[![](https://security.humanativaspa.it/sec/wp-content/uploads/2022/04/Screenshot-2022-04-22-at-14.21.38.png)](https://security.humanativaspa.it/sec/wp-content/uploads/2022/04/Screenshot-2022-04-22-at-14.21.38.png)

To use **Haruspex**, instead, we follow these steps:

1. Analyze our target binary and manually add/modify functions if needed.
2. Copy the script into our “ghidra\_scripts” directory.
3. Open the Script Manager in Ghidra and run the script (or run it via the Tools > Haruspex menu or the shortcut “H”).
4. Enter an output path in which the pseudo-code will be saved.

This will extract all pseudo-code and save it to the specified output directory:

[![](https://security.humanativaspa.it/sec/wp-content/uploads/2022/04/Screenshot-2022-04-22-at-17.19.30.png)](https://security.humanativaspa.it/sec/wp-content/uploads/2022/04/Screenshot-2022-04-22-at-17.19.30.png)

At this point, we can browse the exported pseudo-code with our favorite IDE:

[![](https://security.humanativaspa.it/sec/wp-content/uploads/2022/04/Screenshot-2022-04-23-at-10.10.05-vscode.png)](https://security.humanativaspa.it/sec/wp-content/uploads/2022/04/Screenshot-2022-04-23-at-10.10.05-vscode.png)

Finally, we can use Semgrep with my custom C/C++ rules to (re)discover some of the vulnerabilities:

#### Buffer overflows

[![](https://security.humanativaspa.it/sec/wp-content/uploads/2022/04/Screenshot-2022-04-23-at-10.43.52-bof3.png)](https://security.humanativaspa.it/sec/wp-content/uploads/2022/04/Screenshot-2022-04-23-at-10.43.52-bof3.png)

[![](https://security.humanativaspa.it/sec/wp-content/uploads/2022/04/Screenshot-2022-04-23-at-10.41.49-bof1.png)](https://security.humanativaspa.it/sec/wp-content/uploads/2022/04/Screenshot-2022-04-23-at-10.41.49-bof1.png)

[![](https://security.humanativaspa.it/sec/wp-content/uploads/2022/04/Screenshot-2022-04-23-at-10.43.08-bof2.png)](https://security.humanativaspa.it/sec/wp-content/uploads/2022/04/Screenshot-2022-04-23-at-10.43.08-bof2.png)

[![](https://security.humanativaspa.it/sec/wp-content/uploads/2022/04/Screenshot-2022-04-23-at-10.45.20-bof4.png)](https://security.humanativaspa.it/sec/wp-content/uploads/2022/04/Screenshot-2022-04-23-at-10.45.20-bof4.png)

The buffer overflow in the “debug” command is not immediately discoverable by my default “raptor-insecure-api-scanf-etc” rule, because the target binary calls a variation of the fscanf() API function: \_\_isoc99\_fscanf(). This requires some customization to be detected.

#### Format string bugs

[![](https://security.humanativaspa.it/sec/wp-content/uploads/2022/04/Screenshot-2022-04-23-at-10.49.39-fmt.png)](https://security.humanativaspa.it/sec/wp-content/uploads/2022/04/Screenshot-2022-04-23-at-10.49.39-fmt.png)

As expected, all format string bugs are detected by the “raptor-format-string-bugs” rule.

#### OS command injection

Although the calls to sprintf(), stpcpy(), and strcat() that build the “tcpdump” command string are flagged by my ruleset, the specific instance of command injection that I’ve described in my advisory is not detected by the “raptor-command-injection” rule. Since the vulnerable code path is slightly convoluted and the injection involves abusing a [GTFObins trick](https://gtfobins.github.io/gtfobins/tcpdump/), this vulnerability can only be detected manually by [understanding the context](https://youtu.be/7Ysy6iA2sqA).

The bottom line is: not all vulnerabilities can be discovered through automated means. For some of them, you still need to use your brain 🤯  While effective, **tools such as static analyzers and fuzzers can’t do the entire job**. However, some degree of automation still helps: tools can guide you by showing where to apply focus.

![](https://security.humanativaspa.it/sec/wp-content/uploads/2022/04/Screenshot-2022-04-19-at-09.47.28-1024x575.jpg)

In closing, don’t forget the most important lesson… Go get your hands dirty and have fun!